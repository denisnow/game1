<!doctype html>

<html lang="en">

	<head>

		<meta charset="utf-8">
		<title>Game 1</title>

		<style>

			@import url("https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap");

			body {
				background-image: url('./img/bg.gif');
			}

			.board {
				position: absolute;
 				width: 396px;
				left: 50%;
				top: 50%;
				margin: -200px 0 0 -198px;
				cursor: default;
			}

			.block {
				position: absolute;
			}

			.blockNumber {
				display: table-cell;
				position: relative;
				text-align: center;
				vertical-align: middle;
				height: 96px;
 				width: 96px;
			}

			.text {
				background-color: white;
				opacity: 0.77;
				font-family: "Roboto Mono", monospace;
				font-size: 28px;
				color: #298f91;
			}

			.clickable {
				cursor: pointer;
			}

		</style>

	</head>

	<body>

		<noscript>
			<span class="text">This page requires JavaScript.</span><br><br>
			<span class="text">Your browser doesn't support JavaScript or JavaScript is disabled.</span><br><br>
			<span class="text">Here are the <a href="https://www.enable-javascript.com/">instructions how to enable JavaScript in your browser</a>.</span>
		</noscript>

		<script>

			var matrix,	// 2D array with block elements
				board,	// board element
				voidC;	// void coordinates

			function renderBoard() {

				function makeMatrixAndRenderBlocks() {

					var block, blockNumber, arr;
					var arrIndex = 0;

					function makeArray() {

						var isSolvable, inversionsCount, nullIndex;

						function shuffleArray() {

							var random, temp;

							for (var i = arr.length-1; i > 0; i--) {
								random = Math.floor(Math.random()*(i+1));
								if (arr[random] !== arr[i]) {
									temp = arr[random];
									arr[random] = arr[i];
									arr[i] = temp;
								}
							}
						}

						arr = [];
						for (var i = 0; i < 16; i++) arr.push(i);
						while (!isSolvable) {
							shuffleArray();
							inversionsCount = 0;
							for (i = 0; i < 15; i++) {
								if (arr[i] === 0) {
									nullIndex = i;
									continue;
								}
								for (var j = i+1; j < 16; j++) {
									if (arr[i] > arr[j] && arr[j] !== 0) inversionsCount++;
								}
							}
							if (!(inversionsCount%2)) for (j = 0; j < 9; j++) if (nullIndex === [4,5,6,7,12,13,14,15][j]) isSolvable = true;
							if (inversionsCount%2) for (j = 0; j < 9; j++) if (nullIndex === [0,1,2,3,8,9,10,11][j]) isSolvable = true;
						}
					}

					makeArray();
					matrix = [];
					for (var i = 0; i < 4; i++) {
						matrix[i] = [];
						for (var j = 0; j < 4; j++) {
							if (arr[arrIndex]) {
								block = document.createElement("div");
								block.className = "block";
								block.setAttribute("style", "left: " + 100*j + "px; top: " + 100*i + "px;");
								block.m=i;
								block.n=j;
								blockNumber = document.createElement("div");
								blockNumber.className = "blockNumber text";
								blockNumber.textContent = arr[arrIndex];
								block.appendChild(blockNumber);
								board.appendChild(block);
								matrix[i][j] = block;
							}
							else {
								voidC = {};
								voidC.m = i;
								voidC.n = j;
							}
							arrIndex++;
						}
					}
				}

				board = document.createElement("div");
				board.className = "board";
				document.body.appendChild(board);
				makeMatrixAndRenderBlocks();
			}

			function makeBoardResponsive() {

				board.clickHandler = function(e) {

					if (e.target.parentNode.m === voidC.m || e.target.parentNode.n === voidC.n) {
						e.target.parentNode.className = "block";
						board.makeBlocksStatic();
						board.targetElement = e.target.parentNode;
						board.moveBlocks();
					}
				}

				board.mouseOverHandler = function(e) {

					if (e.target.parentNode.m === voidC.m || e.target.parentNode.n === voidC.n) {
						e.target.parentNode.className += " clickable";
					}
				}

				board.mouseOutHandler = function(e) {

					if (e.target.parentNode.m === voidC.m || e.target.parentNode.n === voidC.n) {
						e.target.parentNode.className = "block";
					}
				}

				board.makeBlocksResponsive = function() {

					board.addEventListener("click", board.clickHandler);
					board.addEventListener("mouseover", board.mouseOverHandler);
				}

				board.makeBlocksStatic = function() {

					board.removeEventListener("click", board.clickHandler);
					board.removeEventListener("mouseover", board.mouseOverHandler);
				}

				board.moveUp = function() {

					for (var i = voidC.m+1; i <= board.targetElement.m; i++) {
						matrix[i][voidC.n].setAttribute("style", "left: " + 100*voidC.n + "px; top: " + (100*i-board.pxCount) + "px;");
						if (board.pxCount === 100) {
							matrix[i][voidC.n].m--;
							matrix[i-1][voidC.n] = matrix[i][voidC.n];
						}
					}
					if (board.pxCount === 100) voidC.m += board.amountOfBlocks;
					}

				board.moveDown = function() {

					for (var i = voidC.m-1; i >= board.targetElement.m; i--) {
						matrix[i][voidC.n].setAttribute("style", "left: " + 100*voidC.n + "px; top: " + (100*i+board.pxCount) + "px;");
						if (board.pxCount === 100) {
							matrix[i][voidC.n].m++;
							matrix[i+1][voidC.n] = matrix[i][voidC.n];
						}
					}
					if (board.pxCount === 100) voidC.m -= board.amountOfBlocks;
				}

				/*
				board.verticalMove = function() {

					board.vd = (voidC.m-board.targetElement.m)/board.amountOfBlocks; //vector direction

					for (var i = voidC.m-board.vd; i*board.vd >= board.targetElement.m*board.vd; i -= board.vd) {
						matrix[i][voidC.n].setAttribute("style", "left: " + 100*voidC.n + "px; top: " + (100*i+board.pxCount*board.vd) + "px;");
						if (board.pxCount === 100) {
							matrix[i][voidC.n].m += board.vd;
							matrix[i+board.vd][voidC.n] = matrix[i][voidC.n];
						}
					}
					if (board.pxCount === 100) voidC.m -= board.amountOfBlocks*board.vd;
				}
				*/				
				
				board.moveToTheRight = function() {

					for (var i = voidC.n-1; i >= board.targetElement.n; i--) {
						matrix[voidC.m][i].setAttribute("style", "left: " + (100*i+board.pxCount) + "px; top: " + 100*voidC.m + "px;");
						if (board.pxCount === 100) {
							matrix[voidC.m][i].n++;
							matrix[voidC.m][i+1] = matrix[voidC.m][i];
						}
					}
					if (board.pxCount === 100) voidC.n -= board.amountOfBlocks;
				}

				board.moveToTheLeft = function() {

					for (var i = voidC.n+1; i <= board.targetElement.n; i++) {
						matrix[voidC.m][i].setAttribute("style", "left: " + (100*i-board.pxCount) + "px; top: " + 100*voidC.m + "px;");
						if (board.pxCount === 100) {
							matrix[voidC.m][i].n--;
							matrix[voidC.m][i-1] = matrix[voidC.m][i];
						}
					}
					if (board.pxCount === 100) voidC.n += board.amountOfBlocks;
				}
				
				/*
				board.horizontalMove = function() {

					board.vd = (voidC.n-board.targetElement.n)/board.amountOfBlocks; //vector direction

					for (var i = voidC.n-board.vd; i*board.vd >= board.targetElement.n*board.vd; i -= board.vd) {
						matrix[voidC.m][i].setAttribute("style", "left: " + (100*i+board.pxCount*board.vd) + "px; top: " + 100*voidC.m + "px;");
						if (board.pxCount === 100) {
							matrix[voidC.m][i].n += board.vd;
							matrix[voidC.m][i+board.vd] = matrix[voidC.m][i];
						}
					}
					if (board.pxCount === 100) voidC.n -= board.amountOfBlocks*board.vd;
				}
				*/

				board.checkMovingDirection = function() {

					if (board.targetElement.m !== voidC.m) {
						if (board.targetElement.m > voidC.m) board.moveBlocksPartially = board.moveUp;
						else board.moveBlocksPartially = board.moveDown;
					}
					else {
						if (board.targetElement.n < voidC.n) board.moveBlocksPartially = board.moveToTheRight;
						else board.moveBlocksPartially = board.moveToTheLeft;
					}
				}

				/*
				board.checkMovingAxis = function() {

					if (board.targetElement.m !== voidC.m) board.moveBlocksPartially = board.verticalMove;
					else board.moveBlocksPartially = board.horizontalMove;
				}
				*/

				board.checkIsSorted = function() {

					board.temp = 0;
					for (var i = 3; i >= 0; i--) {
						for (var j = 3; j >= 0; j--) {
							if (matrix[i][j]) {
								if (board.temp) {
									if (i === 0 && j === 0) {
										board.isSorted = true;
										board.removeEventListener("mouseout", board.mouseOutHandler);
										return;
									}
									if (Number(matrix[i][j].firstChild.textContent) !== board.temp-1) return;
								}
								board.temp = matrix[i][j].firstChild.textContent;
							}
						}
					}
				}

				board.moveBlocks = function() {

					board.pxCount = 0;
					board.amountOfBlocks = Math.abs(board.targetElement.m-voidC.m || board.targetElement.n-voidC.n);
					board.checkMovingDirection();
					board.intervalID = setInterval(function() {
						board.moveBlocksPartially();
						board.pxCount += 10;
						if (board.pxCount === 110) {
							matrix[voidC.m][voidC.n] = 0;
							clearInterval(board.intervalID);
							board.checkIsSorted();
							if (!board.isSorted) board.makeBlocksResponsive();
						}
					}, 3);
				}

				board.makeBlocksResponsive();
				board.addEventListener("mouseout", board.mouseOutHandler);
			}

			renderBoard();
			makeBoardResponsive();

		</script>

	</body>

</html>